// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: river_migration.sql

package dbsqlc

import (
	"context"
	"strings"
	"time"
)

const riverMigrationDeleteAssumingMainMany = `-- name: RiverMigrationDeleteAssumingMainMany :many
DELETE FROM /* TEMPLATE: schema */river_migration
WHERE version IN (/*SLICE:version*/?)
RETURNING
    created_at,
    version
`

type RiverMigrationDeleteAssumingMainManyRow struct {
	CreatedAt time.Time
	Version   int64
}

func (q *Queries) RiverMigrationDeleteAssumingMainMany(ctx context.Context, db DBTX, version []int64) ([]*RiverMigrationDeleteAssumingMainManyRow, error) {
	query := riverMigrationDeleteAssumingMainMany
	var queryParams []interface{}
	if len(version) > 0 {
		for _, v := range version {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:version*/?", strings.Repeat(",?", len(version))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:version*/?", "NULL", 1)
	}
	rows, err := db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigrationDeleteAssumingMainManyRow
	for rows.Next() {
		var i RiverMigrationDeleteAssumingMainManyRow
		if err := rows.Scan(&i.CreatedAt, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationDeleteByLineAndVersionMany = `-- name: RiverMigrationDeleteByLineAndVersionMany :many
DELETE FROM /* TEMPLATE: schema */river_migration
WHERE line = ?1
    AND version IN (/*SLICE:version*/?)
RETURNING line, version, created_at
`

type RiverMigrationDeleteByLineAndVersionManyParams struct {
	Line    string
	Version []int64
}

func (q *Queries) RiverMigrationDeleteByLineAndVersionMany(ctx context.Context, db DBTX, arg *RiverMigrationDeleteByLineAndVersionManyParams) ([]*RiverMigration, error) {
	query := riverMigrationDeleteByLineAndVersionMany
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Line)
	if len(arg.Version) > 0 {
		for _, v := range arg.Version {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:version*/?", strings.Repeat(",?", len(arg.Version))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:version*/?", "NULL", 1)
	}
	rows, err := db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigration
	for rows.Next() {
		var i RiverMigration
		if err := rows.Scan(&i.Line, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationGetAllAssumingMain = `-- name: RiverMigrationGetAllAssumingMain :many
SELECT
    created_at,
    version
FROM /* TEMPLATE: schema */river_migration
ORDER BY version
`

type RiverMigrationGetAllAssumingMainRow struct {
	CreatedAt time.Time
	Version   int64
}

// This is a compatibility query for getting existing migrations before the
// `line` column was added to the table in version 005. We need to make sure to
// only select non-line properties so the query doesn't error on older schemas.
// (Even if we use `SELECT *` below, sqlc materializes it to a list of column
// names in the generated query.)
func (q *Queries) RiverMigrationGetAllAssumingMain(ctx context.Context, db DBTX) ([]*RiverMigrationGetAllAssumingMainRow, error) {
	rows, err := db.QueryContext(ctx, riverMigrationGetAllAssumingMain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigrationGetAllAssumingMainRow
	for rows.Next() {
		var i RiverMigrationGetAllAssumingMainRow
		if err := rows.Scan(&i.CreatedAt, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationGetByLine = `-- name: RiverMigrationGetByLine :many
SELECT line, version, created_at
FROM /* TEMPLATE: schema */river_migration
WHERE line = ?1
ORDER BY version
`

func (q *Queries) RiverMigrationGetByLine(ctx context.Context, db DBTX, line string) ([]*RiverMigration, error) {
	rows, err := db.QueryContext(ctx, riverMigrationGetByLine, line)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigration
	for rows.Next() {
		var i RiverMigration
		if err := rows.Scan(&i.Line, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationInsert = `-- name: RiverMigrationInsert :one
INSERT INTO /* TEMPLATE: schema */river_migration (
    line,
    version
) VALUES (
    ?1,
    ?2
) RETURNING line, version, created_at
`

type RiverMigrationInsertParams struct {
	Line    string
	Version int64
}

// Insert a migration.
//
// This is supposed to be a batch insert, but various limitations of the
// combined SQLite + sqlc has left me unable to find a way of injecting many
// arguments en masse (like how we slightly abuse arrays to pull it off for the
// Postgres drivers), so we loop over many insert operations instead, with the
// expectation that this may be fixable in the future. Because SQLite targets
// will often be local and therefore with a very minimal round trip compared to
// a network, looping over operations is probably okay performance-wise.
func (q *Queries) RiverMigrationInsert(ctx context.Context, db DBTX, arg *RiverMigrationInsertParams) (*RiverMigration, error) {
	row := db.QueryRowContext(ctx, riverMigrationInsert, arg.Line, arg.Version)
	var i RiverMigration
	err := row.Scan(&i.Line, &i.Version, &i.CreatedAt)
	return &i, err
}

const riverMigrationInsertAssumingMain = `-- name: RiverMigrationInsertAssumingMain :one
INSERT INTO /* TEMPLATE: schema */river_migration (
    version
) VALUES (
    ?1
)
RETURNING
    created_at,
    version
`

type RiverMigrationInsertAssumingMainRow struct {
	CreatedAt time.Time
	Version   int64
}

func (q *Queries) RiverMigrationInsertAssumingMain(ctx context.Context, db DBTX, version int64) (*RiverMigrationInsertAssumingMainRow, error) {
	row := db.QueryRowContext(ctx, riverMigrationInsertAssumingMain, version)
	var i RiverMigrationInsertAssumingMainRow
	err := row.Scan(&i.CreatedAt, &i.Version)
	return &i, err
}

const tableExists = `-- name: TableExists :one
SELECT EXISTS (
    SELECT 1
    FROM /* TEMPLATE: schema */sqlite_master WHERE type = 'table' AND name = cast(?1 AS text)
)
`

func (q *Queries) TableExists(ctx context.Context, db DBTX, table string) (int64, error) {
	row := db.QueryRowContext(ctx, tableExists, table)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}
