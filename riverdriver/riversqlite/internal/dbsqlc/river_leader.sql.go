// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: river_leader.sql

package dbsqlc

import (
	"context"
)

const leaderAttemptElect = `-- name: LeaderAttemptElect :execrows
INSERT INTO /* TEMPLATE: schema */river_leader (
    leader_id,
    elected_at,
    expires_at
) VALUES (
    ?1,
    coalesce(cast(?2 AS text), datetime('now', 'subsec')),
    datetime(coalesce(cast(?2 AS text), datetime('now', 'subsec')), 'subsec', cast(?3 as text))
)
ON CONFLICT (name)
    DO NOTHING
`

type LeaderAttemptElectParams struct {
	LeaderID string
	Now      *string
	TTL      string
}

func (q *Queries) LeaderAttemptElect(ctx context.Context, db DBTX, arg *LeaderAttemptElectParams) (int64, error) {
	result, err := db.ExecContext(ctx, leaderAttemptElect, arg.LeaderID, arg.Now, arg.TTL)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const leaderAttemptReelect = `-- name: LeaderAttemptReelect :execrows
INSERT INTO /* TEMPLATE: schema */river_leader (
    leader_id,
    elected_at,
    expires_at
) VALUES (
    ?1,
    coalesce(cast(?2 AS text), datetime('now', 'subsec')),
    datetime(coalesce(cast(?2 AS text), datetime('now', 'subsec')), 'subsec', cast(?3 as text))
)
ON CONFLICT (name)
    DO UPDATE SET
        expires_at = EXCLUDED.expires_at
    WHERE
        leader_id = EXCLUDED.leader_id
`

type LeaderAttemptReelectParams struct {
	LeaderID string
	Now      *string
	TTL      string
}

func (q *Queries) LeaderAttemptReelect(ctx context.Context, db DBTX, arg *LeaderAttemptReelectParams) (int64, error) {
	result, err := db.ExecContext(ctx, leaderAttemptReelect, arg.LeaderID, arg.Now, arg.TTL)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const leaderDeleteExpired = `-- name: LeaderDeleteExpired :execrows
DELETE FROM /* TEMPLATE: schema */river_leader
WHERE expires_at < coalesce(cast(?1 AS text), datetime('now', 'subsec'))
`

func (q *Queries) LeaderDeleteExpired(ctx context.Context, db DBTX, now *string) (int64, error) {
	result, err := db.ExecContext(ctx, leaderDeleteExpired, now)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const leaderGetElectedLeader = `-- name: LeaderGetElectedLeader :one
SELECT elected_at, expires_at, leader_id, name
FROM /* TEMPLATE: schema */river_leader
`

func (q *Queries) LeaderGetElectedLeader(ctx context.Context, db DBTX) (*RiverLeader, error) {
	row := db.QueryRowContext(ctx, leaderGetElectedLeader)
	var i RiverLeader
	err := row.Scan(
		&i.ElectedAt,
		&i.ExpiresAt,
		&i.LeaderID,
		&i.Name,
	)
	return &i, err
}

const leaderInsert = `-- name: LeaderInsert :one
INSERT INTO /* TEMPLATE: schema */river_leader(
    elected_at,
    expires_at,
    leader_id
) VALUES (
    coalesce(cast(?1 AS text), cast(?2 AS text), datetime('now', 'subsec')),
    coalesce(cast(?3 AS text), datetime(coalesce(cast(?2 AS text), datetime('now', 'subsec')), 'subsec', cast(?4 as text))),
    ?5
) RETURNING elected_at, expires_at, leader_id, name
`

type LeaderInsertParams struct {
	ElectedAt *string
	Now       *string
	ExpiresAt *string
	TTL       string
	LeaderID  string
}

func (q *Queries) LeaderInsert(ctx context.Context, db DBTX, arg *LeaderInsertParams) (*RiverLeader, error) {
	row := db.QueryRowContext(ctx, leaderInsert,
		arg.ElectedAt,
		arg.Now,
		arg.ExpiresAt,
		arg.TTL,
		arg.LeaderID,
	)
	var i RiverLeader
	err := row.Scan(
		&i.ElectedAt,
		&i.ExpiresAt,
		&i.LeaderID,
		&i.Name,
	)
	return &i, err
}

const leaderResign = `-- name: LeaderResign :execrows
DELETE
FROM /* TEMPLATE: schema */river_leader
WHERE leader_id = ?1
`

func (q *Queries) LeaderResign(ctx context.Context, db DBTX, leaderID string) (int64, error) {
	result, err := db.ExecContext(ctx, leaderResign, leaderID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
