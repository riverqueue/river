// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: river_queue.sql

package dbsqlc

import (
	"context"
	"strings"
	"time"
)

const queueCreateOrSetUpdatedAt = `-- name: QueueCreateOrSetUpdatedAt :one
INSERT INTO /* TEMPLATE: schema */river_queue (
    created_at,
    metadata,
    name,
    paused_at,
    updated_at
) VALUES (
    coalesce(cast(?1 AS text), datetime('now', 'subsec')),
    json(cast(?2 AS blob)),
    ?3,
    cast(?4 AS text),
    coalesce(cast(?5 AS text), cast(?1 AS text), datetime('now', 'subsec'))
) ON CONFLICT (name) DO UPDATE
SET
    updated_at = EXCLUDED.updated_at
RETURNING name, created_at, metadata, paused_at, updated_at
`

type QueueCreateOrSetUpdatedAtParams struct {
	Now       *string
	Metadata  []byte
	Name      string
	PausedAt  *string
	UpdatedAt *string
}

func (q *Queries) QueueCreateOrSetUpdatedAt(ctx context.Context, db DBTX, arg *QueueCreateOrSetUpdatedAtParams) (*RiverQueue, error) {
	row := db.QueryRowContext(ctx, queueCreateOrSetUpdatedAt,
		arg.Now,
		arg.Metadata,
		arg.Name,
		arg.PausedAt,
		arg.UpdatedAt,
	)
	var i RiverQueue
	err := row.Scan(
		&i.Name,
		&i.CreatedAt,
		&i.Metadata,
		&i.PausedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const queueDeleteExpired = `-- name: QueueDeleteExpired :many
DELETE FROM /* TEMPLATE: schema */river_queue
WHERE name IN (
    SELECT name
    FROM /* TEMPLATE: schema */river_queue
    WHERE river_queue.updated_at < ?1
    ORDER BY name ASC
    LIMIT ?2
)
RETURNING name, created_at, metadata, paused_at, updated_at
`

type QueueDeleteExpiredParams struct {
	UpdatedAtHorizon time.Time
	Max              int64
}

func (q *Queries) QueueDeleteExpired(ctx context.Context, db DBTX, arg *QueueDeleteExpiredParams) ([]*RiverQueue, error) {
	rows, err := db.QueryContext(ctx, queueDeleteExpired, arg.UpdatedAtHorizon, arg.Max)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverQueue
	for rows.Next() {
		var i RiverQueue
		if err := rows.Scan(
			&i.Name,
			&i.CreatedAt,
			&i.Metadata,
			&i.PausedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queueGet = `-- name: QueueGet :one
SELECT name, created_at, metadata, paused_at, updated_at
FROM /* TEMPLATE: schema */river_queue
WHERE name = ?1
`

func (q *Queries) QueueGet(ctx context.Context, db DBTX, name string) (*RiverQueue, error) {
	row := db.QueryRowContext(ctx, queueGet, name)
	var i RiverQueue
	err := row.Scan(
		&i.Name,
		&i.CreatedAt,
		&i.Metadata,
		&i.PausedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const queueList = `-- name: QueueList :many
SELECT name, created_at, metadata, paused_at, updated_at
FROM /* TEMPLATE: schema */river_queue
ORDER BY name ASC
LIMIT ?1
`

func (q *Queries) QueueList(ctx context.Context, db DBTX, max int64) ([]*RiverQueue, error) {
	rows, err := db.QueryContext(ctx, queueList, max)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverQueue
	for rows.Next() {
		var i RiverQueue
		if err := rows.Scan(
			&i.Name,
			&i.CreatedAt,
			&i.Metadata,
			&i.PausedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queueNameList = `-- name: QueueNameList :many
SELECT name
FROM /* TEMPLATE: schema */river_queue
WHERE
    name > cast(?1 AS text)
    AND (cast(?2 AS text) = '' OR LOWER(name) LIKE '%' || LOWER(cast(?2 AS text)) || '%')
    AND name NOT IN (/*SLICE:exclude*/?)
ORDER BY name ASC
LIMIT ?4
`

type QueueNameListParams struct {
	After   string
	Match   string
	Exclude []string
	Max     int64
}

func (q *Queries) QueueNameList(ctx context.Context, db DBTX, arg *QueueNameListParams) ([]string, error) {
	query := queueNameList
	var queryParams []interface{}
	queryParams = append(queryParams, arg.After)
	queryParams = append(queryParams, arg.Match)
	if len(arg.Exclude) > 0 {
		for _, v := range arg.Exclude {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:exclude*/?", strings.Repeat(",?", len(arg.Exclude))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:exclude*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Max)
	rows, err := db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queuePause = `-- name: QueuePause :execrows
UPDATE /* TEMPLATE: schema */river_queue
SET
    paused_at = CASE WHEN paused_at IS NULL THEN coalesce(cast(?1 AS text), datetime('now', 'subsec')) ELSE paused_at END,
    updated_at = CASE WHEN paused_at IS NULL THEN coalesce(cast(?1 AS text), datetime('now', 'subsec')) ELSE updated_at END
WHERE CASE WHEN cast(?2 AS text) = '*' THEN true ELSE name = ?2 END
`

type QueuePauseParams struct {
	Now  *string
	Name string
}

func (q *Queries) QueuePause(ctx context.Context, db DBTX, arg *QueuePauseParams) (int64, error) {
	result, err := db.ExecContext(ctx, queuePause, arg.Now, arg.Name)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const queueResume = `-- name: QueueResume :execrows
UPDATE /* TEMPLATE: schema */river_queue
SET
    paused_at = NULL,
    updated_at = CASE WHEN paused_at IS NOT NULL THEN coalesce(cast(?1 AS text), datetime('now', 'subsec')) ELSE updated_at END
WHERE CASE WHEN cast(?2 AS text) = '*' THEN true ELSE name = ?2 END
`

type QueueResumeParams struct {
	Now  *string
	Name string
}

func (q *Queries) QueueResume(ctx context.Context, db DBTX, arg *QueueResumeParams) (int64, error) {
	result, err := db.ExecContext(ctx, queueResume, arg.Now, arg.Name)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const queueUpdate = `-- name: QueueUpdate :one
UPDATE /* TEMPLATE: schema */river_queue
SET
    metadata = CASE WHEN cast(?1 AS boolean) THEN json(cast(?2 AS blob)) ELSE metadata END,
    updated_at = datetime('now', 'subsec')
WHERE name = ?3
RETURNING name, created_at, metadata, paused_at, updated_at
`

type QueueUpdateParams struct {
	MetadataDoUpdate bool
	Metadata         []byte
	Name             string
}

func (q *Queries) QueueUpdate(ctx context.Context, db DBTX, arg *QueueUpdateParams) (*RiverQueue, error) {
	row := db.QueryRowContext(ctx, queueUpdate, arg.MetadataDoUpdate, arg.Metadata, arg.Name)
	var i RiverQueue
	err := row.Scan(
		&i.Name,
		&i.CreatedAt,
		&i.Metadata,
		&i.PausedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
