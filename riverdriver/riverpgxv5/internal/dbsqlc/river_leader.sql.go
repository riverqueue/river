// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: river_leader.sql

package dbsqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const leaderAttemptElect = `-- name: LeaderAttemptElect :execrows
INSERT INTO /* TEMPLATE: schema */river_leader (leader_id, elected_at, expires_at)
    -- @ttl is inserted as as seconds rather than a duration because ` + "`" + `lib/pq` + "`" + ` doesn't support the latter
    VALUES ($1, coalesce($2::timestamptz, now()), coalesce($2::timestamptz, now()) + make_interval(secs => $3))
ON CONFLICT (name)
    DO NOTHING
`

type LeaderAttemptElectParams struct {
	LeaderID string
	Now      *time.Time
	TTL      float64
}

func (q *Queries) LeaderAttemptElect(ctx context.Context, db DBTX, arg *LeaderAttemptElectParams) (int64, error) {
	result, err := db.Exec(ctx, leaderAttemptElect, arg.LeaderID, arg.Now, arg.TTL)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const leaderAttemptReelect = `-- name: LeaderAttemptReelect :execrows
INSERT INTO /* TEMPLATE: schema */river_leader (leader_id, elected_at, expires_at)
    VALUES ($1, coalesce($2::timestamptz, now()), coalesce($2::timestamptz, now()) + make_interval(secs => $3))
ON CONFLICT (name)
    DO UPDATE SET
        expires_at = EXCLUDED.expires_at
    WHERE
        river_leader.leader_id = $1
`

type LeaderAttemptReelectParams struct {
	LeaderID string
	Now      *time.Time
	TTL      float64
}

func (q *Queries) LeaderAttemptReelect(ctx context.Context, db DBTX, arg *LeaderAttemptReelectParams) (int64, error) {
	result, err := db.Exec(ctx, leaderAttemptReelect, arg.LeaderID, arg.Now, arg.TTL)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const leaderDeleteExpired = `-- name: LeaderDeleteExpired :execrows
DELETE FROM /* TEMPLATE: schema */river_leader
WHERE expires_at < coalesce($1::timestamptz, now())
`

func (q *Queries) LeaderDeleteExpired(ctx context.Context, db DBTX, now *time.Time) (int64, error) {
	result, err := db.Exec(ctx, leaderDeleteExpired, now)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const leaderGetElectedLeader = `-- name: LeaderGetElectedLeader :one
SELECT elected_at, expires_at, leader_id, name
FROM /* TEMPLATE: schema */river_leader
`

func (q *Queries) LeaderGetElectedLeader(ctx context.Context, db DBTX) (*RiverLeader, error) {
	row := db.QueryRow(ctx, leaderGetElectedLeader)
	var i RiverLeader
	err := row.Scan(
		&i.ElectedAt,
		&i.ExpiresAt,
		&i.LeaderID,
		&i.Name,
	)
	return &i, err
}

const leaderInsert = `-- name: LeaderInsert :one
INSERT INTO /* TEMPLATE: schema */river_leader(
    elected_at,
    expires_at,
    leader_id
) VALUES (
    coalesce($1::timestamptz, coalesce($2::timestamptz, now())),
    coalesce($3::timestamptz, coalesce($2::timestamptz, now()) + make_interval(secs => $4)),
    $5
) RETURNING elected_at, expires_at, leader_id, name
`

type LeaderInsertParams struct {
	ElectedAt *time.Time
	Now       *time.Time
	ExpiresAt *time.Time
	TTL       float64
	LeaderID  string
}

func (q *Queries) LeaderInsert(ctx context.Context, db DBTX, arg *LeaderInsertParams) (*RiverLeader, error) {
	row := db.QueryRow(ctx, leaderInsert,
		arg.ElectedAt,
		arg.Now,
		arg.ExpiresAt,
		arg.TTL,
		arg.LeaderID,
	)
	var i RiverLeader
	err := row.Scan(
		&i.ElectedAt,
		&i.ExpiresAt,
		&i.LeaderID,
		&i.Name,
	)
	return &i, err
}

const leaderResign = `-- name: LeaderResign :execrows
WITH currently_held_leaders AS (
  SELECT elected_at, expires_at, leader_id, name
  FROM /* TEMPLATE: schema */river_leader
  WHERE leader_id = $1::text
  FOR UPDATE
),
notified_resignations AS (
    SELECT pg_notify(
        concat(coalesce($2::text, current_schema()), '.', $3::text),
        json_build_object('leader_id', leader_id, 'action', 'resigned')::text
    )
    FROM currently_held_leaders
)
DELETE FROM /* TEMPLATE: schema */river_leader USING notified_resignations
`

type LeaderResignParams struct {
	LeaderID        string
	Schema          pgtype.Text
	LeadershipTopic string
}

func (q *Queries) LeaderResign(ctx context.Context, db DBTX, arg *LeaderResignParams) (int64, error) {
	result, err := db.Exec(ctx, leaderResign, arg.LeaderID, arg.Schema, arg.LeadershipTopic)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
