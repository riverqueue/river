// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: river_queue.sql

package dbsqlc

import (
	"context"
	"time"
)

const queueCreateOrSetUpdatedAt = `-- name: QueueCreateOrSetUpdatedAt :one
INSERT INTO /* TEMPLATE: schema */river_queue (
    created_at,
    metadata,
    name,
    paused_at,
    updated_at
) VALUES (
    coalesce($1::timestamptz, now()),
    coalesce($2::jsonb, '{}'::jsonb),
    $3::text,
    coalesce($4::timestamptz, NULL),
    coalesce($5::timestamptz, $1::timestamptz, now())
) ON CONFLICT (name) DO UPDATE
SET
    updated_at = EXCLUDED.updated_at
RETURNING name, created_at, metadata, paused_at, updated_at
`

type QueueCreateOrSetUpdatedAtParams struct {
	Now       *time.Time
	Metadata  []byte
	Name      string
	PausedAt  *time.Time
	UpdatedAt *time.Time
}

func (q *Queries) QueueCreateOrSetUpdatedAt(ctx context.Context, db DBTX, arg *QueueCreateOrSetUpdatedAtParams) (*RiverQueue, error) {
	row := db.QueryRow(ctx, queueCreateOrSetUpdatedAt,
		arg.Now,
		arg.Metadata,
		arg.Name,
		arg.PausedAt,
		arg.UpdatedAt,
	)
	var i RiverQueue
	err := row.Scan(
		&i.Name,
		&i.CreatedAt,
		&i.Metadata,
		&i.PausedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const queueDeleteExpired = `-- name: QueueDeleteExpired :many
DELETE FROM /* TEMPLATE: schema */river_queue
WHERE name IN (
    SELECT name
    FROM /* TEMPLATE: schema */river_queue
    WHERE river_queue.updated_at < $1
    ORDER BY name ASC
    LIMIT $2::bigint
)
RETURNING name, created_at, metadata, paused_at, updated_at
`

type QueueDeleteExpiredParams struct {
	UpdatedAtHorizon time.Time
	Max              int64
}

func (q *Queries) QueueDeleteExpired(ctx context.Context, db DBTX, arg *QueueDeleteExpiredParams) ([]*RiverQueue, error) {
	rows, err := db.Query(ctx, queueDeleteExpired, arg.UpdatedAtHorizon, arg.Max)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverQueue
	for rows.Next() {
		var i RiverQueue
		if err := rows.Scan(
			&i.Name,
			&i.CreatedAt,
			&i.Metadata,
			&i.PausedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queueGet = `-- name: QueueGet :one
SELECT name, created_at, metadata, paused_at, updated_at
FROM /* TEMPLATE: schema */river_queue
WHERE name = $1::text
`

func (q *Queries) QueueGet(ctx context.Context, db DBTX, name string) (*RiverQueue, error) {
	row := db.QueryRow(ctx, queueGet, name)
	var i RiverQueue
	err := row.Scan(
		&i.Name,
		&i.CreatedAt,
		&i.Metadata,
		&i.PausedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const queueList = `-- name: QueueList :many
SELECT name, created_at, metadata, paused_at, updated_at
FROM /* TEMPLATE: schema */river_queue
ORDER BY name ASC
LIMIT $1
`

func (q *Queries) QueueList(ctx context.Context, db DBTX, max int32) ([]*RiverQueue, error) {
	rows, err := db.Query(ctx, queueList, max)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverQueue
	for rows.Next() {
		var i RiverQueue
		if err := rows.Scan(
			&i.Name,
			&i.CreatedAt,
			&i.Metadata,
			&i.PausedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queueNameList = `-- name: QueueNameList :many
SELECT name
FROM /* TEMPLATE: schema */river_queue
WHERE name > $1::text
    AND ($2::text = '' OR name ILIKE '%' || $2::text || '%')
    AND ($3::text[] IS NULL OR name != ALL($3))
ORDER BY name
LIMIT $4::int
`

type QueueNameListParams struct {
	After   string
	Match   string
	Exclude []string
	Max     int32
}

func (q *Queries) QueueNameList(ctx context.Context, db DBTX, arg *QueueNameListParams) ([]string, error) {
	rows, err := db.Query(ctx, queueNameList,
		arg.After,
		arg.Match,
		arg.Exclude,
		arg.Max,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queuePause = `-- name: QueuePause :execrows
UPDATE /* TEMPLATE: schema */river_queue
SET
    paused_at = CASE WHEN paused_at IS NULL THEN coalesce($1::timestamptz, now()) ELSE paused_at END,
    updated_at = CASE WHEN paused_at IS NULL THEN coalesce($1::timestamptz, now()) ELSE updated_at END
WHERE CASE WHEN $2::text = '*' THEN true ELSE name = $2 END
`

type QueuePauseParams struct {
	Now  *time.Time
	Name string
}

func (q *Queries) QueuePause(ctx context.Context, db DBTX, arg *QueuePauseParams) (int64, error) {
	result, err := db.Exec(ctx, queuePause, arg.Now, arg.Name)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const queueResume = `-- name: QueueResume :execrows
UPDATE /* TEMPLATE: schema */river_queue
SET
    paused_at = NULL,
    updated_at = CASE WHEN paused_at IS NOT NULL THEN coalesce($1::timestamptz, now()) ELSE updated_at END
WHERE CASE WHEN $2::text = '*' THEN true ELSE name = $2 END
`

type QueueResumeParams struct {
	Now  *time.Time
	Name string
}

func (q *Queries) QueueResume(ctx context.Context, db DBTX, arg *QueueResumeParams) (int64, error) {
	result, err := db.Exec(ctx, queueResume, arg.Now, arg.Name)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const queueUpdate = `-- name: QueueUpdate :one
UPDATE /* TEMPLATE: schema */river_queue
SET
    metadata = CASE WHEN $1::boolean THEN $2::jsonb ELSE metadata END,
    updated_at = now()
WHERE name = $3
RETURNING name, created_at, metadata, paused_at, updated_at
`

type QueueUpdateParams struct {
	MetadataDoUpdate bool
	Metadata         []byte
	Name             string
}

func (q *Queries) QueueUpdate(ctx context.Context, db DBTX, arg *QueueUpdateParams) (*RiverQueue, error) {
	row := db.QueryRow(ctx, queueUpdate, arg.MetadataDoUpdate, arg.Metadata, arg.Name)
	var i RiverQueue
	err := row.Scan(
		&i.Name,
		&i.CreatedAt,
		&i.Metadata,
		&i.PausedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
