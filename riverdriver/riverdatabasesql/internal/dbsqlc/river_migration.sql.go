// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: river_migration.sql

package dbsqlc

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const columnExists = `-- name: ColumnExists :one
SELECT EXISTS (
    SELECT column_name
    FROM information_schema.columns 
    WHERE table_name = $1 and column_name = $2
)
`

type ColumnExistsParams struct {
	TableName  interface{}
	ColumnName interface{}
}

func (q *Queries) ColumnExists(ctx context.Context, db DBTX, arg *ColumnExistsParams) (bool, error) {
	row := db.QueryRowContext(ctx, columnExists, arg.TableName, arg.ColumnName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const riverMigrationDeleteAssumingMainMany = `-- name: RiverMigrationDeleteAssumingMainMany :many
DELETE FROM river_migration
WHERE version = any($1::bigint[])
RETURNING
    created_at,
    version
`

type RiverMigrationDeleteAssumingMainManyRow struct {
	CreatedAt time.Time
	Version   int64
}

func (q *Queries) RiverMigrationDeleteAssumingMainMany(ctx context.Context, db DBTX, version []int64) ([]*RiverMigrationDeleteAssumingMainManyRow, error) {
	rows, err := db.QueryContext(ctx, riverMigrationDeleteAssumingMainMany, pq.Array(version))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigrationDeleteAssumingMainManyRow
	for rows.Next() {
		var i RiverMigrationDeleteAssumingMainManyRow
		if err := rows.Scan(&i.CreatedAt, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationDeleteByLineAndVersionMany = `-- name: RiverMigrationDeleteByLineAndVersionMany :many
DELETE FROM river_migration
WHERE line = $1
    AND version = any($2::bigint[])
RETURNING line, version, created_at
`

type RiverMigrationDeleteByLineAndVersionManyParams struct {
	Line    string
	Version []int64
}

func (q *Queries) RiverMigrationDeleteByLineAndVersionMany(ctx context.Context, db DBTX, arg *RiverMigrationDeleteByLineAndVersionManyParams) ([]*RiverMigration, error) {
	rows, err := db.QueryContext(ctx, riverMigrationDeleteByLineAndVersionMany, arg.Line, pq.Array(arg.Version))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigration
	for rows.Next() {
		var i RiverMigration
		if err := rows.Scan(&i.Line, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationGetAllAssumingMain = `-- name: RiverMigrationGetAllAssumingMain :many
SELECT
    created_at,
    version
FROM river_migration
ORDER BY version
`

type RiverMigrationGetAllAssumingMainRow struct {
	CreatedAt time.Time
	Version   int64
}

// This is a compatibility query for getting existing migrations before the
// `line` column was added to the table in version 005. We need to make sure to
// only select non-line properties so the query doesn't error on older schemas.
// (Even if we use `SELECT *` below, sqlc materializes it to a list of column
// names in the generated query.)
func (q *Queries) RiverMigrationGetAllAssumingMain(ctx context.Context, db DBTX) ([]*RiverMigrationGetAllAssumingMainRow, error) {
	rows, err := db.QueryContext(ctx, riverMigrationGetAllAssumingMain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigrationGetAllAssumingMainRow
	for rows.Next() {
		var i RiverMigrationGetAllAssumingMainRow
		if err := rows.Scan(&i.CreatedAt, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationGetByLine = `-- name: RiverMigrationGetByLine :many
SELECT line, version, created_at
FROM river_migration
WHERE line = $1
ORDER BY version
`

func (q *Queries) RiverMigrationGetByLine(ctx context.Context, db DBTX, line string) ([]*RiverMigration, error) {
	rows, err := db.QueryContext(ctx, riverMigrationGetByLine, line)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigration
	for rows.Next() {
		var i RiverMigration
		if err := rows.Scan(&i.Line, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationInsert = `-- name: RiverMigrationInsert :one
INSERT INTO river_migration (
    line,
    version
) VALUES (
    $1,
    $2
) RETURNING line, version, created_at
`

type RiverMigrationInsertParams struct {
	Line    string
	Version int64
}

func (q *Queries) RiverMigrationInsert(ctx context.Context, db DBTX, arg *RiverMigrationInsertParams) (*RiverMigration, error) {
	row := db.QueryRowContext(ctx, riverMigrationInsert, arg.Line, arg.Version)
	var i RiverMigration
	err := row.Scan(&i.Line, &i.Version, &i.CreatedAt)
	return &i, err
}

const riverMigrationInsertMany = `-- name: RiverMigrationInsertMany :many
INSERT INTO river_migration (
    line,
    version
)
SELECT
    $1,
    unnest($2::bigint[])
RETURNING line, version, created_at
`

type RiverMigrationInsertManyParams struct {
	Line    string
	Version []int64
}

func (q *Queries) RiverMigrationInsertMany(ctx context.Context, db DBTX, arg *RiverMigrationInsertManyParams) ([]*RiverMigration, error) {
	rows, err := db.QueryContext(ctx, riverMigrationInsertMany, arg.Line, pq.Array(arg.Version))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigration
	for rows.Next() {
		var i RiverMigration
		if err := rows.Scan(&i.Line, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationInsertManyAssumingMain = `-- name: RiverMigrationInsertManyAssumingMain :many
INSERT INTO river_migration (
    version
)
SELECT
    unnest($1::bigint[])
RETURNING
    created_at,
    version
`

type RiverMigrationInsertManyAssumingMainRow struct {
	CreatedAt time.Time
	Version   int64
}

func (q *Queries) RiverMigrationInsertManyAssumingMain(ctx context.Context, db DBTX, version []int64) ([]*RiverMigrationInsertManyAssumingMainRow, error) {
	rows, err := db.QueryContext(ctx, riverMigrationInsertManyAssumingMain, pq.Array(version))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigrationInsertManyAssumingMainRow
	for rows.Next() {
		var i RiverMigrationInsertManyAssumingMainRow
		if err := rows.Scan(&i.CreatedAt, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tableExists = `-- name: TableExists :one
SELECT CASE WHEN to_regclass($1) IS NULL THEN false
            ELSE true END
`

func (q *Queries) TableExists(ctx context.Context, db DBTX, tableName string) (bool, error) {
	row := db.QueryRowContext(ctx, tableExists, tableName)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
