// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: river_migration.sql

package dbsqlc

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const riverMigrationDeleteAssumingMainMany = `-- name: RiverMigrationDeleteAssumingMainMany :many
DELETE FROM /* TEMPLATE: schema */river_migration
WHERE version = any($1::bigint[])
RETURNING
    created_at,
    version
`

type RiverMigrationDeleteAssumingMainManyRow struct {
	CreatedAt time.Time
	Version   int64
}

func (q *Queries) RiverMigrationDeleteAssumingMainMany(ctx context.Context, db DBTX, version []int64) ([]*RiverMigrationDeleteAssumingMainManyRow, error) {
	rows, err := db.QueryContext(ctx, riverMigrationDeleteAssumingMainMany, pq.Array(version))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigrationDeleteAssumingMainManyRow
	for rows.Next() {
		var i RiverMigrationDeleteAssumingMainManyRow
		if err := rows.Scan(&i.CreatedAt, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationDeleteByLineAndVersionMany = `-- name: RiverMigrationDeleteByLineAndVersionMany :many
DELETE FROM /* TEMPLATE: schema */river_migration
WHERE line = $1
    AND version = any($2::bigint[])
RETURNING line, version, created_at
`

type RiverMigrationDeleteByLineAndVersionManyParams struct {
	Line    string
	Version []int64
}

func (q *Queries) RiverMigrationDeleteByLineAndVersionMany(ctx context.Context, db DBTX, arg *RiverMigrationDeleteByLineAndVersionManyParams) ([]*RiverMigration, error) {
	rows, err := db.QueryContext(ctx, riverMigrationDeleteByLineAndVersionMany, arg.Line, pq.Array(arg.Version))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigration
	for rows.Next() {
		var i RiverMigration
		if err := rows.Scan(&i.Line, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationGetAllAssumingMain = `-- name: RiverMigrationGetAllAssumingMain :many
SELECT
    created_at,
    version
FROM /* TEMPLATE: schema */river_migration
ORDER BY version
`

type RiverMigrationGetAllAssumingMainRow struct {
	CreatedAt time.Time
	Version   int64
}

// This is a compatibility query for getting existing migrations before the
// `line` column was added to the table in version 005. We need to make sure to
// only select non-line properties so the query doesn't error on older schemas.
// (Even if we use `SELECT *` below, sqlc materializes it to a list of column
// names in the generated query.)
func (q *Queries) RiverMigrationGetAllAssumingMain(ctx context.Context, db DBTX) ([]*RiverMigrationGetAllAssumingMainRow, error) {
	rows, err := db.QueryContext(ctx, riverMigrationGetAllAssumingMain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigrationGetAllAssumingMainRow
	for rows.Next() {
		var i RiverMigrationGetAllAssumingMainRow
		if err := rows.Scan(&i.CreatedAt, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationGetByLine = `-- name: RiverMigrationGetByLine :many
SELECT line, version, created_at
FROM /* TEMPLATE: schema */river_migration
WHERE line = $1
ORDER BY version
`

func (q *Queries) RiverMigrationGetByLine(ctx context.Context, db DBTX, line string) ([]*RiverMigration, error) {
	rows, err := db.QueryContext(ctx, riverMigrationGetByLine, line)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigration
	for rows.Next() {
		var i RiverMigration
		if err := rows.Scan(&i.Line, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationInsert = `-- name: RiverMigrationInsert :one
INSERT INTO /* TEMPLATE: schema */river_migration (
    line,
    version
) VALUES (
    $1,
    $2
) RETURNING line, version, created_at
`

type RiverMigrationInsertParams struct {
	Line    string
	Version int64
}

func (q *Queries) RiverMigrationInsert(ctx context.Context, db DBTX, arg *RiverMigrationInsertParams) (*RiverMigration, error) {
	row := db.QueryRowContext(ctx, riverMigrationInsert, arg.Line, arg.Version)
	var i RiverMigration
	err := row.Scan(&i.Line, &i.Version, &i.CreatedAt)
	return &i, err
}

const riverMigrationInsertMany = `-- name: RiverMigrationInsertMany :many
INSERT INTO /* TEMPLATE: schema */river_migration (
    line,
    version
)
SELECT
    $1,
    unnest($2::bigint[])
RETURNING line, version, created_at
`

type RiverMigrationInsertManyParams struct {
	Line    string
	Version []int64
}

func (q *Queries) RiverMigrationInsertMany(ctx context.Context, db DBTX, arg *RiverMigrationInsertManyParams) ([]*RiverMigration, error) {
	rows, err := db.QueryContext(ctx, riverMigrationInsertMany, arg.Line, pq.Array(arg.Version))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigration
	for rows.Next() {
		var i RiverMigration
		if err := rows.Scan(&i.Line, &i.Version, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const riverMigrationInsertManyAssumingMain = `-- name: RiverMigrationInsertManyAssumingMain :many
INSERT INTO /* TEMPLATE: schema */river_migration (
    version
)
SELECT
    unnest($1::bigint[])
RETURNING
    created_at,
    version
`

type RiverMigrationInsertManyAssumingMainRow struct {
	CreatedAt time.Time
	Version   int64
}

func (q *Queries) RiverMigrationInsertManyAssumingMain(ctx context.Context, db DBTX, version []int64) ([]*RiverMigrationInsertManyAssumingMainRow, error) {
	rows, err := db.QueryContext(ctx, riverMigrationInsertManyAssumingMain, pq.Array(version))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RiverMigrationInsertManyAssumingMainRow
	for rows.Next() {
		var i RiverMigrationInsertManyAssumingMainRow
		if err := rows.Scan(&i.CreatedAt, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
