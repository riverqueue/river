// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: schema.sql

package dbsqlc

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const columnExists = `-- name: ColumnExists :one
SELECT EXISTS (
    SELECT column_name
    FROM information_schema.columns 
    WHERE table_name = $1::text
        AND table_schema = /* TEMPLATE_BEGIN: schema */ CURRENT_SCHEMA /* TEMPLATE_END */
        AND column_name = $2::text
)
`

type ColumnExistsParams struct {
	TableName  string
	ColumnName string
}

func (q *Queries) ColumnExists(ctx context.Context, db DBTX, arg *ColumnExistsParams) (bool, error) {
	row := db.QueryRowContext(ctx, columnExists, arg.TableName, arg.ColumnName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const indexExists = `-- name: IndexExists :one
SELECT EXISTS (
    SELECT 1
    FROM pg_catalog.pg_class
        JOIN pg_catalog.pg_namespace ON pg_namespace.oid = pg_class.relnamespace
    WHERE pg_class.relname = $1::text
        AND pg_namespace.nspname = coalesce($2::text, current_schema())
        AND pg_class.relkind = 'i'
)
`

type IndexExistsParams struct {
	Index  string
	Schema sql.NullString
}

func (q *Queries) IndexExists(ctx context.Context, db DBTX, arg *IndexExistsParams) (bool, error) {
	row := db.QueryRowContext(ctx, indexExists, arg.Index, arg.Schema)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const indexesExist = `-- name: IndexesExist :many
WITH index_names AS (
    SELECT unnest($2::text[]) as index_name
)
SELECT index_names.index_name::text AS index_name,
       EXISTS (
         SELECT 1
         FROM pg_catalog.pg_class c
         JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
         WHERE n.nspname = coalesce($1::text, current_schema())
         AND c.relname = index_names.index_name
         AND c.relkind = 'i'
       ) AS exists
FROM index_names
`

type IndexesExistParams struct {
	Schema     sql.NullString
	IndexNames []string
}

type IndexesExistRow struct {
	IndexName string
	Exists    bool
}

func (q *Queries) IndexesExist(ctx context.Context, db DBTX, arg *IndexesExistParams) ([]*IndexesExistRow, error) {
	rows, err := db.QueryContext(ctx, indexesExist, arg.Schema, pq.Array(arg.IndexNames))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*IndexesExistRow
	for rows.Next() {
		var i IndexesExistRow
		if err := rows.Scan(&i.IndexName, &i.Exists); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const schemaGetExpired = `-- name: SchemaGetExpired :many
SELECT schema_name::text
FROM information_schema.schemata
WHERE schema_name LIKE $1
    AND schema_name < $2
ORDER BY schema_name
`

type SchemaGetExpiredParams struct {
	Prefix     interface{}
	BeforeName interface{}
}

func (q *Queries) SchemaGetExpired(ctx context.Context, db DBTX, arg *SchemaGetExpiredParams) ([]string, error) {
	rows, err := db.QueryContext(ctx, schemaGetExpired, arg.Prefix, arg.BeforeName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var schema_name string
		if err := rows.Scan(&schema_name); err != nil {
			return nil, err
		}
		items = append(items, schema_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tableExists = `-- name: TableExists :one
SELECT CASE WHEN to_regclass($1) IS NULL THEN false
            ELSE true END
`

func (q *Queries) TableExists(ctx context.Context, db DBTX, schemaAndTable string) (bool, error) {
	row := db.QueryRowContext(ctx, tableExists, schemaAndTable)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
