// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: river_leader.sql

package dbsqlc

import (
	"context"

	"time"
)

const leadershipAttemptElect = `-- name: LeadershipAttemptElect :execrows
INSERT INTO river_leader(name, leader_id, elected_at, expires_at)
  VALUES ($1::text, $2::text, now(), now() + $3::interval)
ON CONFLICT (name)
  DO NOTHING
`

type LeadershipAttemptElectParams struct {
	Name     string
	LeaderID string
	TTL      time.Duration
}

func (q *Queries) LeadershipAttemptElect(ctx context.Context, db DBTX, arg LeadershipAttemptElectParams) (int64, error) {
	result, err := db.Exec(ctx, leadershipAttemptElect, arg.Name, arg.LeaderID, arg.TTL)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const leadershipAttemptReelect = `-- name: LeadershipAttemptReelect :execrows
INSERT INTO river_leader(name, leader_id, elected_at, expires_at)
  VALUES ($1::text, $2::text, now(), now() + $3::interval)
ON CONFLICT (name)
  DO UPDATE SET
    expires_at = now() + $3::interval
  WHERE
    EXCLUDED.leader_id = $2::text
`

type LeadershipAttemptReelectParams struct {
	Name     string
	LeaderID string
	TTL      time.Duration
}

func (q *Queries) LeadershipAttemptReelect(ctx context.Context, db DBTX, arg LeadershipAttemptReelectParams) (int64, error) {
	result, err := db.Exec(ctx, leadershipAttemptReelect, arg.Name, arg.LeaderID, arg.TTL)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const leadershipDeleteExpired = `-- name: LeadershipDeleteExpired :exec
DELETE FROM river_leader
WHERE name = $1::text
  AND expires_at < now()
`

func (q *Queries) LeadershipDeleteExpired(ctx context.Context, db DBTX, name string) error {
	_, err := db.Exec(ctx, leadershipDeleteExpired, name)
	return err
}

const leadershipResign = `-- name: LeadershipResign :exec
WITH currently_held_leaders AS (
  SELECT
    elected_at, expires_at, leader_id, name
  FROM
    river_leader
  WHERE
    name = $1::text
    AND leader_id = $2::text
  FOR UPDATE
),
notified_resignations AS (
  SELECT
    pg_notify('river_leaderhip', json_build_object('name', name, 'leader_id', leader_id, 'action', 'resigned')::text),
    currently_held_leaders.name
  FROM
    currently_held_leaders)
DELETE FROM river_leader USING notified_resignations
WHERE river_leader.name = notified_resignations.name
`

type LeadershipResignParams struct {
	Name     string
	LeaderID string
}

func (q *Queries) LeadershipResign(ctx context.Context, db DBTX, arg LeadershipResignParams) error {
	_, err := db.Exec(ctx, leadershipResign, arg.Name, arg.LeaderID)
	return err
}
